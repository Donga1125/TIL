## 1. 운영체제 기초 활용

### 1) 운영체제 종류

- 운영체제 특징
    - 사용자 편리성: 한정된 시스템 자원을 효과적으로 사용할 수 있도록 관리 및 운영
    - 인터페이스 기능 : 컴퓨터 시스템과 사용자를 연결
    - 스케쥴링 : 다중 사용자와 다중 응용 프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케쥴링 담당
    - 자원 관리 : CPU, 메모리 공각, 기억장치, 입출력 장치 등의 자원을 관리
    - 제어 기능 : 입출력 장치와 사용자 프로그램을 제어
- 운영체제의 기능
    - 운영체제는 기능별로 제어 프로그램과 처리 프로그램으로 나눠질 수 있다.
    - 제어 프로그램 Control Program
        - 감시 프로그램 Supervisor Program : 각종 프로그램의 실행과 시스템 전체의 작동 상태 감시 및 감독
        - 작업 제어 프로그램 Job Control Program : 작업의 연속 처리를 위한 스케쥴 및 시스템 자원 할당 담당
        - 데이터 관리 프로그램 Data Management Program : 주기억장치와 보조기억장치 사이의 데이터 전송과 보조기억장치의 자료 갱신 및 유지보수 기능을 수행
    - 처리 프로그램 Processing Program
        - 언어 번역 프로그램 Language Translate Program : 원시 프로그램을 기계어 형태의 목적 프로그램으로 번역하는 프로그램으로 어셈블러, 컴파일러, 인터프리터가 있음
        - 서비스 프로그램 Service Program : 효율성을 위해 사용 빈도가 높은 프로그램으로 링커, 정렬/합병 프로그램, 라이브러리, 유틸리티 프로그램이 있음
        - 문제 프로그램 Problem Program : 특정 업무 해결을 위해 사용자가 작성한 프로그램

- 운영체제에서 커널의 기능
    - 운영체제는 크게 인터페이스(쉘)과 커널의 구조이다.
    - 운영체제의 핵심적인 기능들이 커널에 모여있다면, 인터페이스(쉘)는 이러한 커널을 사용자가 보다 편리하게 사용할 수 있게 해준다.
    - **쉘 Shell**
        - 쉘은 사용자가 입력시킨 명령어 라인을 읽어 필요한 기능을 실행시키는 명령어 해석기이다.
        - 시스템과 사용자 간의 인터페이스를 제공한다.
        - 여러 가지의 내장 명령어를 가지고 있다.
    - **커널 Kernel**
        - 커널을 운영체제의 핵심이 되는 기능들이 모여 있는 컴퓨터 프로그램이다.
        - 컴퓨터가 부팅될 때 주기억 장치에 적재된 후 상주하면서 실행하며, 프로그램과 하드웨어 간의 인터페이스 역할을 담당한다.
        - 커널의 기능
            - 프로세스 관리 : 프로세스 스케줄링 및 동기화 관리 담당. 프로세스 생성과 제거, 시작과 정지, 메시지 전달 등의 기능 담당
            - 기억장치 관리 : 프로세스에게 메모리 할당 및 회수 관리 담당
            - 주변장치 관리 : 입 출력 장치 스케쥴링 및 전반적인 관리 담당
            - 파일 관리 : 파일 관리 파일의 생성과 삭제, 변경, 유지 등의 관리 담당

### 2) 메모리 관리

- 메모리 관리 기법
    - 메모리 반입 기법
    - **메모리 배치 기법**
        - 디스크에 있는 프로세스를 주기억장치의 어느 위치에 저장할 것인지 결정하는 기법
        - **배치 기법**
            - 최초 적합 First Fit : 프로세스가 적재될 수 있는 가용 공간 중에서 첫 번째 분할에 할당하는 방식
            - 최적 적합 Best Fit : 가용 공간 중에서 가장 크기가 비슷한 공간을 선택하여 프로세스를 적재하는 방식. 공백 최소화 장점이 있음
            - 최악 적합 Worst-Fit : 프로세스의 가용 공간 중에서 가장 큰 공간에 할당하는 방식
    - **메모리 할당 기법**
        - 실행해야 할 프로세스를 주기억장치에 어떤 방법으로 할당할 것인지 결정하는 기법
        - 주기억장치 할당 기법의 종류
            - 연속 할당 기법 : 실행을 위한 각 프로세스를 주기억장치 공간 내에서 인접되게 연속하여 저장하는 방법
            - 분산 할당 기법 : 하나의 프로세스를 여러 개의 조각으로 나누어 주기억장치 공간 내 분산하여 배치하는 기법
        - **페이징 기법**
            - 페이징 기법은 가상기억장치 내의 프로세스를 일정하게 분할하여 주기억장치의 분산된 공간에 적재시킨 후 프로세스를 수행시키는 기법이다.
            - 실제 공간은 페이지 크기와 같은 페이지 프레임으로 나누어 사용한다.
        - **세그먼테이션 기법 (Segmentation)**
            - 가상기억장치 내의 프로세스를 가변적인 크기의 블록으로 나누고 메모리를 할당하는 기법이다.
            - 분할 형태가 배열이나 함수와 같은 논리적인 다양한 크기의 가변적인 크기로 관리한다.
    - **메모리 교체 기법**
        - 교체 기법 유형
            - FIFO : 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와 가장 오래 있던 페이지를 교체하는 기법
            - LRU (Least Recently Used) : 사용된 시간을 확인하여 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체하는 기법. 프로그램의 지역성의 원리에 따라서 최근에 참조된 페이지는 앞으로도 참조될 가능성이 크고, 최근에 참조되지 않은 페이지는 앞으로도 참조되지 않을 가능성이 크다는 전제로 구현된 알고리즘
            - LFU (Least Frequently Used) : 사용된 횟수를 확인하여 참조 횟수가 가장 적은 페이지를 선택하여 교체하는 기법. 기억장치에 저장된 페이지 중에서 사용한 횟수가 가장 적은 페이지를 교체하는 알고리즘
            - OPT (OPTimal Replacement) : 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
            - NUR (Not Used Recently) : LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법. 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 가능성이 크다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음
            - SCR (Second Chance Replacement) : 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법으로 FIFO의 단점을 보완하는 기법

- 교체 기법 알고리즘 계산  (Page Fault의 횟수를 묻는 문제로 자주 등장)
    - FIFO
        - 주기억장치 페이지에 순차적으로 참조 스트링이 들어오고, 페이지 교체는 가장 먼저 들어온 페이지 먼저 교체.
        1. 프로세스에 3개의 페이지 프레임이 고정으로 할당되어 있고, 초기에 3개의 페이지 프레임들이 모두 비어 있다고 가정한다.
        2. 다음의 참조 스트링을 처리하는 동안 알고리즘 별 페이지 부재가 몇 회 발생하는지 계산한다.
    - LRU
        - 사용된 시간을 확인하여 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체하는 알고리즘
        1. 프로세스에 3개의 페이지 프레임이 고정으로 할당되어 있고, 초기에 3개의 페이지 프레임들이 모두 비어있다고 가정
        2. 다음의 참조 스트링을 처리하는 동안 알고리즘 별 페이지 부재가 몇 회 발생하는지 계산한다.
    - LFU
        - 사용된 횟수를 확인하여 참조 횟수가 가장 적은 페이지를 선택하여 교체하는 알고리즘이다.
        1. 프로세스에 4개의 페이지 프레임이 고정으로 할당되어 있고, 초기에 4개의 페이지 프레임들이 모두 비어 있다고 가정한다.
        2. 다음의 참조 스트링을 처리하는 동안 알고리즘 별 페이지 부재가 몇 회 발생하는지 계산한다.



- 페이징 기법의 문제 및 해결방안
    - 페이징 기법의 문제점 - 스레싱 (Thrashing)
        - 스레싱은 어떤 프로세스가 계속적으로 페이지 부재가 발생하여 프로세스의 실제 처리 시간 보다 페이지 교체 시간이 더 많아지는 현상이다.
        - 오류율이 클수록 스레싱이 많이 발생한 것이고, 스레싱으로 인해 전체 시스템의 성능 및 처리율은 저하된다.
        - 페이지 부재가 계속 증가하여 기억장치 접근 시간이 증가한다.
    - 페이징 기법의 문제점 해결 방안
        - 워킹 세트 Working Set
            - 워킹 세트는 각 프로세스가 많이 참조하는 페이지들의 집합을 주기억장치 공간에 계속 상주하게 하여 빈번한 페이지 교체 현상을 줄이고자 하는 기법이다.
        - 페이지 부재 빈도(PFF; Page-Fault Frequency)
            - 페이지 부재 빈도는 페이지 부재율의 상환과 하한을 정해서 직접적으로 페이지 부재율을 예측하고 조절하는 기법이다.
            - 페이지 부재 비율에 따라 페이지 프레임 개수를 조절한다.


### 3) 프로세스 스케쥴링

- 프로세스 개념
    - 프로세스는 CPU에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 실행 중인 프로그램이다.
    - 프로세스는 작업(Job) 또는 태스크 라고도 한다.
- 프로세스 상태
    - 하나의 프로세스는 여러 가지 이벤트에 의해 일련의 서로 구분되는 상태 변화를 겪는다.
    - 다음과 같은 상태를 가진다.
        - 생성 (Create) 상태 : 사용자에 의해 프로세스가 생성된 상태
        - 준비 (Ready) 상태 : CPU를 할당받을 수 있는 상태. 준비 리스트 : 각각 우선 순위를 부여하여 가장 높은 우선순위를 갖는 프로세스가 다음 순서에 CPU를 할당 받음.
        - 실행 (Running) 상태 : 프로세스가 CPU를 할당받아 동작 중인 상태
        - 대기 (Waiting) 상태 : 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태. 대기 리스트: 우선순위가 존재하지 않음
        - 완료 (Complete) 상태/ 종료(Terminated; Exit) 상태 : 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태

- 스레드 (Thread)
    - 개념
        - 스레드는 프로세스보다 가벼운, 독립적으로 수행되는 순차적인 제어의 흐름이며, 실행 단위이다.
        - 스레드는 프로세스에서 실행 제어만 분리한 실행 단위로 한 개의 프로세스는 여러 개의 스레드를 가질 수 있다.
    - **스레드 종류**
        - 생성 주체에 따라 커널 수준 스레드와 사용자 수준 스레드로 구분한다.

      | 항목 | 커널 수준 스레드                              | 사용자 수준 스레드 |
              |----|----------------------------------------| --- |
      | 개념 | - 스레드를 생성하고 스케쥴링하는 주체가 커널인 스레드  <br/>  | - 사용자 영역에서 라이브러리를 통해 구현되는 스레드  |
      | 장점 | - 커널이 각 스레드를 개별적으로 관리할 수 있음 <br/> - 다른 스레드가 입출력 작업이 다 끝날 때까지 다른 스레드를 사용해 다른 작업을 진행할 수 있음 <br/>- 커널이 직접 스레드를 제공해 주기 때문에 안정성과 다양한 기능이 제공 |- 스케쥴링 결정이나 동기화를 위해 커널 모드로 전환하지 않기 떄문에 인터럽트가 발생할 때 오버헤드가 적음. <br/>- 사용자 영역 스레드에서 행동하기 때문에 OS스케쥴러의 문맥교환(Context Switch)이 없음.
      | 단점 | - 사용자 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 오버헤드가 많음.<br/> - 사용자 스레드에 비해 생성 및 관리하는 것이 느림 | - 스케쥴링 우선순위를 지원하지 않으므로 어떤 스레드가 먼저 동작할지 알 수 없음. </br>- 여러 개의 사용자 스레드 중 하나의 스레드가 시스템 호출 등으로 블록이 걸리면 나머지 모든 스레드 역시 블록됨
  - 프로세스 스케쥴링
    - **비선점형 스케쥴링 알고리즘 유형**
    
        | 알고리즘 유형                                   | 동작 방식                                                                                                                                                                        | 특징                                                |
          |-------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
          | 우선순위 </br> Priority                       | - 각 프로세스 별로 우선순위가 주어지고, 우선순위에 따라 CPU를 할당함</br> - 동일 순위는 FCFS                                                                                                                 | - 주요/긴급 프로세스에 대한 우선 처리 </br>-  설정, 자원 상황 등에 따른 우선순위 선정 |
          | 기한부 </br>Deadline                         | - 작업들이 명시된 시간이나 기한 내에 완료되도록 계획                                                                                                                                               | - 요청에 명시된 시간 내 처리를 보장                             |
          | FCFS </br> First Come First Served        | - 프로세스가 대기 큐에 도착한 순서에 따라 CPU를 할당함. </br> - FIFO 알고리즘 이라고 도 함                                                                                                                 | - 도착한 순서대로 처리                                                |
          | SJF  </br> Shorted Job First              | - 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원 점유 </br> - 준비 큐 작업 중 가장 짧은 작업부터 수행, 평균 대기시간 최소 </br>- CPU 요구시간이 긴 작업과 짧은 작업 간의 불평등 심하여, CPU 요구시간이 긴 프로세스는 기아 현상 발생 | - 기아 현상 발생 가능성  |
     | HRN </br> Highest Response Ratio Next          | - 대기 중인 프로세스 중 대기시간이 긴 프로세스 일 경우 우선순위가 높아지게 하여 우선순위를 결정하는 스케줄링 기법 </br> - 서비스 받은 시간과 서비스를 기다린 시간을 고려하여 가변적 우선순위를 설정                                                          | - 기아 현상 최소화 기법                                                                                                                                                          |
        
      ** 프로세스 스케쥴링 알고리즘 계산 방법은 문제 풀면서 확실하게 익힐것 !
     (FIFO가 제일 중점적)

- **프로세스 관리-교착 상태**
    - **교착상태 발생 조건 (상점비화)**
        - 상호배제 (Mutual Exclusive) : 프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없는 상태
        - 점유와 대기 (Hold & Wait) : 한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하여 대기하고 있는 상태
        - 비선점 (Non Preemption) : 한 프로세스가 점유한 자원에 대해 다른 프로세스가 선점할 수 없고, 오직 점유한 프로세스만이 해제 가능한 상태
        - 환형 대기 (Circular Wait) : 두 개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성한 상태
    - **교착 상태 해결 방법 (예회발복)**
        - 예방 (Prevention) : 상호배제를 제외한 나머지 교착상태 발생 조건을 위배하는 방안
        - 회피 (Avoidance) : 안전한 상태를 유지할 수 있는 요구만 수락 (프로세스 별 자원 최대 요구량 확보)
        - 발견 (Detection) : 사스템의 상태를 감시 알고리즘 통해 교착 상태 검사
        - 복구 (Recovery) : 교착상태가 없어질 때까지 프로세스를 순차적으로 Kill하여 제거, 희생자 선택해야하고 기아 상태 발생



### 4) 환경 변수

- **Unix 시스템**
    - env, set, printenv 명령어들은 변수 없이 사용하면, 모든 환경 변수 및 그에 따른 모든 값을 보여 준다.
    - env, set은 환경 변수를 설정하는 데 쓰일 수도 있으며 쉘에 직접 통합되기도 한다.
    - printenv 는 변수 이름을 명령어에 단일 변수로 주면, 하나의 단일 변수 인쇄에 쓰일 수 있다.
    - env : 전역 변수 설정 및 조회
    - set : 사용자 환경 변수 설정 및 조회
    - export : 사용자 환경 변수를 전역 변수로 설정. 사용자가 생성하는 변수는 export 명령어로 표시하지 않는 한 현재 쉘에 국한.