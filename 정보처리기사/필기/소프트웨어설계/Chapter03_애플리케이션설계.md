## 1. 공통 모듈 설계

### 1) 재사용

- 재사용의 유형

**함수와 객체 재사용** - 클래스나 함수 단위로 구현한 소스코드를 재사용

**컴포넌트 재사용** - 컴포넌트 단위로 재사용. 컴포넌트의 인터페이스를 통해 통신

**애플리케이션 재사용** - 공통기능을 제공하는 애플리케이션과 기능을 공유하여 재사용

### 2) 공통 모듈

- 모듈화 개념:

모듈화는 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 상화함으로써 소프트웨어 제품의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리를 쉽게 하는 기법이다.

- **바람직한 모듈 설계 방안**

모듈의 독립성과 재사용성을 높이기 위하여 결합도는 낮추고 응집도는 높인다.

모듈의 복잡도와 중복성을 줄이고 일관성을 유지한다.

모듈의 기능은 예측이 가능해야하며, 지나치게 제한적이어서는 안된다.

적당한 모듈의 크기를 유지한다.

모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.

유지보수가 용이해야 하고, 이식성을 고려해야한다.

- 모듈화 측정 지표

좋은 모듈화란 용도에 맞게 잘 구분된 기능을 가진 모듈들로 세분화하는 것이다.

개별 모듈은 독립적으로 주어진 역할 만을 수행하며, 타 모듈에 의존성이 높지 않아야한다.

- **응집도 cohesion**

  모듈의 내부 요소들의 서로 관련되어 있는 정도

  모듈이 독립적인 기능으로 정의되어 있는 정도

  응집도의 유형은 ‘우연적<논리적<시간적<절차적<통신적<순차적<기능적 응집도’ 순서로 응집도가 높아진다.

- **결합도 coupling**

  모듈 간에 상호 의존하는 정도

  두 모듈 사이의 연관 관계를 맺고 있는 정도

  결합도의 유형은 ‘내용> 공통> 외부> 제어> 스탬프> 자료 결합도’ 순으로 결합도가 낮아진다.


### 3) 설계 모델링

- 소프트웨어 설계 유형

**자료 구조 설계 (Data Structure Design)** - 요구분석 단계에서 생성된 정보를 바탕으로 소프트웨어를 구현하는데 필요한 자료 구조로 변환하는 과정을 설계

**아키텍처 설계 (Architecture Design)** - 예비 설계 또는 상위 수준 설계. 소프트웨어 시스템의 전체 구조를 기술. 소프트웨어를 구성하는 컴포넌트 간의 관계를 정의

**인터페이스 설계 (Interface Design)** - 소프트웨어와 상호 작용하는 컴퓨터 시스템, 사용자 등이 어떻게 통신하는 지를 설계

**프로시저 설계 (Procedure Design)** - 모듈이 수행할 기능을 절차적 기술로 바꾸는 설계

**협약에 의한 설계 (Design by Contract)** - 클래스에 대한 여러 가정을 공유하도록 명세한 설계. 소프트웨어 컴포넌트에 대한 정확한 인터페이스 명세를 위하여 선행조건, 결과조건, 불변조건을 나타내는 설계 방법.

- 소프트웨어 설계 원리

**상향식 설계 (Bottom - Up Design)** - 하위 기능들로부터 시작하여 제일 상위에 있는 기능으로 접근해가는 방식. 인터페이스가 성립되어 있어야 기능 추가가 쉬움. 기존 컴포넌트들을 조합하여 시스템을 개발하는 경우에 적합

**하향식 설계 (Top - Down Design)** - 소프트웨어 설계 시 제일 상위에 있는 기능에서 시작하여 기능을 하위 기능들로 분할해 가면서 설계하는 방식. 레벨이 낮은 데이터 구조의 세부 사항은 설계 초기 단계에서 필요. 시스템 명세가 정확한 경우와 모든 것을 새로 개발하는 작업에 적합.

- 코드 설계 종류

**연상 코드 (Mnemonic Code)** - 코드만 보고 대상을 연상할 수 있도록 명칭 일부를 약호 형태로 넣어 구성된 코드. ex) KR, US

**블록 코드 (Block Code) -** 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 코드. 구분 코드라고도 불림.  ex) 전화번호→ 지역번호 - 국번 - 일련번호 조합

**순차 코드 (Sequence Code) -** 일정한 기준에 따라 순서대로 일련번호를 부여한 코드

**표의 숫자 코드 (Significant Digit Code) -** 대상 자료의 물리적인 수치인 길이, 넓이, 용량 등을 표시한 코드

**십진 코드 (Decimal Code) -** 10진수 형태로 표현한 코드

**그룹 분류식 코드 (Group Classification Code) -** 대상을 기준에 따라 대분류, 중분류, 소분류로 구분하여 번호를 부여한 코드

- HIPO 개념:

HIPO (Hierarchy Input Process Output)은 시스템의 분석 및 설계, 문서화할 때 사용되며, 하향식 소프트웬어 개발을 위한 문서화 도구이다.

- HIPO 특징:

체계적인 문서 관리가 가능하다.

기호, 도표 등을 사용해서 보기가 쉽고 이해가 쉽다.

기능과 자료의 의존 관계를 동시에 표현할 수 있다.

변경, 유지보수가 용이하다.

시스템의 기능을 고유 모듈들로 분할하여 이들 간의 인터페이스를 계층구조로 표현한 것을 HIPO차트라고 한다.

### 4) 소프트웨어 아키텍처

- 소프트웨어 아키텍처 패턴 유형
    - **계층화 패턴**: 시스템을 계층(Layer)으로 구분하여 구성하는 패턴. 각 하위 모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공.  계층화 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호 작용이 이루어짐.
    - **클라이언트 - 서버 패턴:** 하나의 서버와 다수의 클라이언트로 구성된 패턴. 사용자가 클라이언트를 통해서 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스 제공. 서버는 계속 클라로부터 요청을 대기
    - **파이프-필터 패턴**: 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 단방향 패턴. 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복. 필터 컴포넌트는 재사용성이 좋고, 추가가 쉽기 때문에 확장이 용이하나, 필터 간 데이터 이동에서 데이터 변환 오버헤드가 발생
    - **브로커 패턴**: 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 사오 작용이 가능한 패턴. 컴포넌트 간의 통신을 조정하는 역할 수행.
    - **모델 - 뷰- 컨트롤러 패턴(MVC):** 대화형 애플리케이션을 모델, 뷰, 컨트롤 뷰 3개의 서브 시스템으로 구조화하는 패턴. MVC 패턴은 각 부분이 별도의 컴포넌트로 분리되어있어 서로 영향을 받지않고 개발 작업 수행 가능
    - **마스터 - 슬레이브 패턴:** 연산, 통신, 조정을 책임지는 마스터와 제어되고 동기화되는 대상인 슽레이브로 구성되는 패턴. 일반적으로 실시간 시스템에서 사용


## 2. 객체 지향 설계

### 1) 객체 지향

- 객체 지향 구성 요소
  - 클래스 : 특정 객체 내에 있는 변수와 메서드를 정의하는 일종의 틀. 객체 지향 프로그래밍에서 데이터를 추상화하는 단위. 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현. 속성은 변수의 형태로, 행위는 메서드 형태로 선언
  - 객체: 물리적, 추상적으로 자신과 다른 것을 식별 가능한 대상. 클래스에서 정의한 것을 토대로 메모리에 할당됨. 객체마다 각각의 상태와 식별성을 가짐.
  - 메서드: 클래스로부터 생성된 객체를 사용하는 방법. 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산. 전통적 시스템의 함수 또는 프로시저에 해당하는 연산.
  - 메시지: 객체 간 상호 작용을 하기 위한 수단. 객체에게 어떤 행위를 하도록 지시하는 방법. 객체 간의 상호 작용은 메시지를 통해 이루어짐. 메시지는 객체에서 객체로 전달됨.
  - 인스턴스: 객체 지향 기법에서 클래스를 통해 만든 실제의 실형 객체. 클래스에 속한 각각의 객체. 실제로 메모리상에 할당.
  - 속성: 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 단위별로 정의. 성질, 분류, 식별, 수량, 현재 상태 등에 대한 표현
- 객체 지향 기법
  - **캡슐화:** 서로 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 기법. 결합도가 낮아지고 재사용이 용이. 인터페이스가 단순화됨. 정보 은닉과 관계가 깊음. 변경 발생 시 오류의 파급 효과가 적음.
  - **상속성:** 상위 클래스의 속성과 메서드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법
  - **다형성:** 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력. 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질
    - **오버로딩 (Overloading)**

      매개변수의 유형과 개수를 다르게 하여 같은 이름의 메서드를 여러 개 가지는 기법

    - **오버라이딩 (Overriding)**

      상위 클래스에서 정의한 일반 메서드의 구현을 하위 클래스에서 무시하고 재정의할 수 있는 기법

  - **추상화:** 공통 성질을 추출하여 추상 클래스를 설정하는 기법. 종류로는 과정 추상화, 자료 추상화, 제어 추상화가 있음.
  - **정보 은닉:** 코드 내부 데이터와 메서드를 숨기고 공개 인터페이스를 통해서만 접근이 가능하도록 하는 코드 보안 기술. 필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부 시스템이 다른 모듈의 구현에 영향을 받지 않게 설계됨. 모듈 사이 독립성을 유지하는데 도움을 줌.
  - **관계성:** 두 개 이상의 엔터티 형에서 데이터를 참조하는 관계를 나타내는 기법. 종류로는 연관화, 분류화, 집단화, 일반화, 특수화가 있음.
- 객체 지향 설계 원칙 (SOLID)
  - 단일 책임의 원칙 : 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙.
  - 개방 폐쇄의 원칙: 소프트웨어의 구성요소 (컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야한다는 원칙
  - 리스코프 치환의 원칙: 서브 타입 (상속받은 하위 클래스)은 어디서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 한다는 원칙
  - 인터페이스 분리의 원칙: 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아햐 한다는 원칙. 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안된다는 원칙
  - 의존성 역전의 원칙: 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙
- 객체 지향 방법론 종류
  - OOSE: 유스케이스에 의한 접근 방법으로 유스 케이스를 모든 모델의 근간으로 활용되는 방법론. 분석, 설계, 구현 단계로 구성. 기능적 요구사항 중심의 시스템
  - OMT (만든이 **럼바우**): 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론. 분석 절차는 객체 모델링 → 동적 모델링 → 기능 모델링 순으로 진행

  **객체 모델링** - 정보 모델링이라고도 하며, 시스템에서 요구하는 객체를 찾고 객체 간의 관계를 정의하는 모델링. 가장 중요하며 선행되어 진행.

  **동적 모델링** - 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현하는 모델링

  **기능 모델링** - 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현하는 모델링

  - OOD: 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론. 분석과 설계의 분리가 불가능!

### 2) 디자인 패턴

- 디자인 패턴 종류
  - **생성 패턴**
    - Builder : 복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법과 객체를 구현하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴. 생성과 표기를 분리해서 복잡한 객체를 생성
    - Prototype: 처음부터 일반적인 원형을 만들어놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴. 기존 객체를 복제함으로써 객체를 생성
    - Factory Method: 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴. 생성할 객체의 클래스를 국한하지 않고 객체를 생성
    - Abstract Factory: 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴으로 이 패턴을 통해 생성된 클래스에서는 사용자에게 API를 제공하고, 구체적인 구현은 Concrete Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴. 동일한 주제의 다른 팩토리를 묶음
    - Singleton: 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴. 한 클래스에 한 객체만 존재하도록 제한.
  - **구조 패턴**
    - Bridge: 구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 사용.
    - Decorator: 객체의 결합을 통해 기능을 동적으로 유연하게 확장.
    - Facade: 통합된 인터페이스 제공
    - Flyweight: 여러 개의 가상 인스턴스를 제공하여 메모리 절감
    - Proxy: 특정 객체로의 접근을 제어하기 위한 용도로 사용
    - Composite: 복합 객체와 단일 객체를 동일하게 취급
    - Adapter: 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움.
  - **행위 패턴**
    - Mediator: 상호 작용의 유연한 변경을 지원
    - Interpreter: 문법 자체를 캡슐화하여 사용
    - Iterator: 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 반복자를 사용하여 접근할 수 있는 디자인 패턴.
    - Template Method: 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행
    - Observer: 객체의 상태 변화에 따라 다른 객체의 상태도 연동. 일대다 의존
    - State: 객체의 상태에 따라 행위 내용을 변경
    - Visitor: 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위
    - Command: 요구사항을 객체로 캡슐화
    - Strategy: 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환
    - Memento: 객체를 이전 상태로 복구시켜야 하는 경우, 작업 취소(undo) 요청 가능
    - Chain of Responsibility: 한 요청을 2개 이상의 객체에서 처리

- 디자인 패턴의 장단점
  - 장점
    - 요구사항 변경에 따른 소스 코드 변경을 최소화할 수 있게 해줌
    - 소프트웨어 코드의 품질을 향상시킬 수 있음.
    - 설계 변경 요청에 대한 유연한 대처가 가능
    - 범용적인 코딩 스타일 적용 가능
    - 개발자 간의 원활한 의사소통 가능
    - 재사용을 통한 개발 시간 단축 가능
    - 소프트웨어 구조 파악이 용이
    - 객체 지향 설계 및 구현의 생산성을 높이는 데 적합
    - 소프트웨어의 품질과 생산정을 향상시킬 수 있음
  - 단점
    - 객체 지향 설계/구현 위주로 사용
    - 초기 투자 비용의 부담