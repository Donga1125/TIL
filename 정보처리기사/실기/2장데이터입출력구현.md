### Section 029. 데이터베이스 개요

1. 데이터 저장소
    1. 데이터 저장소는 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것을 의미한다.
2. 데이터베이스 Database
    1. 데이터베이스는 여러 사람에 의해 공동으로 사용될 데이터를 중복으로 배제하여 통합하고, 쉽게 접근하여 처리할 수 있도록 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터이다.
3. DBMS (Database Management System : 데이터베이스 관리 시스템)
    1. 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어이다.
4. **스키마 Schema**
    1. 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.
    2. **스키마 종류**
        1. **외부 스키마 -** 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
        2. **개념 스키마 -** 데이터베이스의 전체적인 논리적 구조. 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재함
        3. **내부 스키마 -** 물리적 저장장치의 입장에서 본 데이터베이스 구조. 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄


### Section 030. 데이터베이스 설계

- 데이터베이스 설계 순서

  요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현

    1. 요구 조건 분석
        1. 데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것.
        2. 데이터베이스 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집한다.
    2. **개념적 설계 (정보 모델링, 개념화)**
        1. 개념적 설계는 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다.
        2. DBMS에 독립적인 개념 스키마를 설계한다.
    3. **논리적 설계 (데이터 모델링)**
        1. 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping) 시키는 과정이다.
        2. 개념적 설계가 개념 스키마를 설계하는 단계라면, 논리적 설계에서는 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계이다.
    4. **물리적 설계 (데이터 구조화)**
        1. 논리적 설계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.
        2. 저장 레코드의 형식, 순서, 접근 경로, 조회 집중 레코드 등의 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사한다.
    5. 데이터베이스 구현
        1. 논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정이다.


### Section 031 ~ 033. 데이터 모델의 개념

1. 데이터 모델
    1. 데이터 모델은 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모델이다.
    2. **데이터 모델 구성 요소 :** 개체, 속성, 관계
    3. **데이터 모델 종류 :** 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
    4. **데이터 모델에 표시할 요소 :** 구조, 연산, 제약 조건

- **데이터 모델에 표시할 요소**
    - 구조 Structure
        - 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현
    - 연산 Operation
        - 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구
    - 제약 조건 Constraint
        - 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건
- **데이터 모델의 구성 요소**
    - **개체 Entity**
        - 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체이다.
        - 독립적으로 존재하거나 그 자체로서도 구별이 가능하며, 유일한 식별자 (Unique Identifier)에 의해 식별된다.
        - 다른 개체와 하나 이상의 관계 (Relationship)가 있다.
    - **속성 Attribute**
        - 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
        - 속성의 수를 Degree 또는 차수라고 한다.
        - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다.
        - 속성의 특성에 따른 분류
            - 기본 속성 Basic Attribute - 업무 분석을 통해 정의한 속성. 속성 중 가장 많고 일반적
            - 설계 속성 Designed Attribute - 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성
            - 파생 속성 Derived Attribute - 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성. 파생 속성은 되도록 적은 수를 정의하는 것이 좋음.
    - **관계 Relationship**
        - 개체와 개체 사이의 논리적인 연결을 의미한다.
        - 관계의 형태
            - 1:1, 1:N, N:N
        - 관계의 종류
            - 종속 관계, 중복 관계, 재귀 관계, 배타 관계
- **데이터 모델의 종류**
    - 개념적 데이터 모델
        - 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세게에 대한 인식을 추상적 개념으로 표현하는 과정이다.
        - 대표적인 개념적 데이터 모델로 E-R 모델이 있다.
            - 개체 타입과 이들 간의 관계 타입을 이용해 현실 세계를 개념적으로 표현한다.

          | 기호 이름  | 의미  |
                      | --- | --- |
          | 사각형 | 개체 (Entity) 타입 |
          | 마름모  | 관계 (Relationship) 타입 |
          | 타원  | 속성 (Attribute) |
          | 이중 타원 | 다중값 속성 (복합 속성) |
          | 밑줄 타원  | 기본키 속성 |
          | 복수 타원  | 복합 속성 |
          | 관계  | 1:1, 1:N 등의 개체 간 관계에 대한 대응수를 선 위에 기술함 |
          | 선, 링크  | 개체 타입과 속성을 연결 |
    - 논리적 데이터 모델
        - 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정이다.
        - 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미

### Section 034 ~ 036 . 관계형 데이터베이스

- 관계형 데이터베이스는 2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 데이터베이스이다.
- IBM에 근무하던 codd에 의해 처음 제안 되었다.
- **관계형 데이터베이스의 구조**
    - Relation (릴레이션)
        - 데이터들을 표(Table)의 형태로 표현한 것으로, 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.
        - 한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
        - 튜플의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변하며, 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
        - 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만 저장한다.
    - Tuple (튜플)
        - 릴레이션을 구성하는 각각의 행
        - 튜플은 속성의 모임으로 구성되며 파일 구조에서 레코드와 같은 의미이다.
        - 튜플의 수를 cardinarity 또는 기수, 대응수라고 한다.
    - Attribute (속성)
        - 데이터베이스를 구성하는 가장 작은 논리적 단위이다.
        - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당되며, 속성은 개체의 특성을 기술한다.
        - 속성의 수를 Degree 또는 차수라고 한다.
    - Domain
        - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자 (Atomic) 값들의 집합이다.
        - 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용된다.

- 관계형 데이터베이스의 제약 조건 - Key
    - 키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.
    - 후보 키 Candidate Key
        - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합니다.
        - 기본키로 사용할 수 있는 속성들을 말한다.
        - 유일성 (Unique) 과 최소성 (Minimality) 을 모두 만족시켜야한다.
    - 기본 키 Primary Key
        - 후보 키 중에서 특별히 선정된 주키 (Main key)이다.
        - 기본 키는 중복된 값과 Null 값을 가질 수 없다.
        - 기본 키는 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.
    - 대체 키 Alternate Key
        - 후보 키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다.
        - 보조키라고도 한다.
    - 슈퍼 키 Super key
        - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키를 말한다.
        - 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
        - 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.
    - 외래 키 Foreign Key
        - 다른 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합을 의미한다.
        - 외래 키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.

- 관계형 데이터베이스의 제약 조건 - 무결성 Integrity
    - 무결성은 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성을 의미한다.
    - **무결성의 종류**
        - **개체 무결성** - 기본 테이블의 기본 키를 구성하는 어떤 속성도 Null 값이나 중복 값을 가질 수 없다는 규정
        - **참조 무결성** - 외래 키 값은 Null 이거나 참조 릴레이션의 기본 키 값과 동일해야함. 즉 릴레이션은 참조할 수 없는 외래 키 값을 가질 수 없다는 규정
        - 그 외에 도메인 무결성, 사용자 정의 무결성, Null 무결성, 고유 무결성, 키 무결성, 관계 무결성이 있다.
    - 데이터 무결성 강화
        - 애플리케이션 - 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 프로그램 내에 추가함.
        - 데이터베이스 트리거 - 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가함.
        - 제약 조건 - 데이터베이스에 제약 조건을 설정하여 무결성을 유지함.

### Section 037. 관계대수 및 관계해석

1. 관계대수
    1. 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는 가를 기술하는 절차적인 언어이다.
2. **순수 관계 연산자**
    1. Select
        1. 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
        2. 릴레이션의 행에 해당하는 튜플을 구하는 것이므로 수평 연산이라고도 함
        3. 기호 - 시그마 σ
    2. Project
        1. 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
        2. 연산 결과에 중복이 발생하면 중복이 제거됨
        3. 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자라고도 함
        4. 기호 - 파이 ∏
    3. Join
        1. 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
        2. Join의 결과는 Cartesion Product (교차곱)를 수행한 다음 Select를 수행한 것과 같음
        3. 기호 - ⋈
    4. Division
        1. R>S 인 두개의 릴레이션이 있을 때 R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
        2. 기호 - ÷

3. 일반 집합 연산자
    1. 합집합 UNION ⋃
    2. 교집합 INTERSECTION ⋂
    3. 차집합 DIFFERENCE –
    4. 교차곱 CARTESIAN PRODUCT ✕

1. 관계 해석 (Relational Calculus)
    1. 관계 해석은 관계 데이터의 연산을 표현하는 방법이다.
    2. 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다.


### Section 038. 이상/함수적 종속

1. 이상 Anomaly
    1. 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복으로 인해 테이블 조작 시 문제가 발생하는 현상을 의미한다.
        1. 삽입 이상 Insertion Anomaly
            1. 테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들로 인해 삽입할 수 없게 되는 현상이다.
        2. 삭제 이상 Deletion Anomaly
            1. 테이블에서 한 튜플을 삭제할 때 의도와는 상관 없는 값들도 함께 삭제되는 연쇄 삭제가 발생하는 현상이다.
        3. 갱신 이상 Update Anomaly
            1. 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상이다.

1. 함수적 종속 Funcional Dependency
    1. 어떤 테이블 R에서 X 와 Y를 각각 R의 속성 집합의 부분 집합이라 하자. 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수적 종속 또는 X 가 Y를 함수적으로 결정한다고 하고, X → Y 로 표기한다.
    2. 함수적 종속은 데이터의 의미를 표현하는 것으로, 현실 세계를 표현하는 제약 조건이 되는 동시에 데이터베이스에서 항상 유지되어야 할 조건이다.
    3. 종류
        1. 완전 함수적 종속 (Full Funtional Dependency)

           어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 x의 어떠한 진부분 집합 X (즉 Z ⊂X) 에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이라고 한다.

        2. 부분 함수적 종속 (Partial Funtional Dependency)

           어떤 테이블 R에서 속성 Y가 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 합니다.

        3. 이행적 함수적 종속 (Transitive Functional Dependency)

           X → Y 이고 Y→ Z를 만족하는 관계를 이행적 함수적 종속이라고 한다.



### Section 039. 정규화

1. 정규화 Nomalization
    - 정규화는 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정이다.
    - 정규화의 목적은 가능한 한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것이다.
2. **정규화 과정** (원부이결다조)
    1. **제 1정규형**
        - 제 1정규형은 테이블 R에 속한 모든 속성의 도메인이 원자 값만으로 되어있는 정규형이다. 즉 테이블의 모든 속성 값이 원자값으로만 되어 있는 정규형이다.
    2. **제 2정규형**
        - 제 2정규형은 테이블 R이 제 1정규형이고, 기본키가 아닌 모든 속성이 기본 키에 대해 완전 함수적 종속을 만족하는 정규형이다.
    3. **제 3정규형**

       제 3정규형은 테이블 R이 제 2정규형이고 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형이다.

    4. BCNF
        - BCNF 는 테이블 R에서 모든 결정자가 후보키 (Cardidate Key)인 정규형이다.
        - 일반적으로 제 3정규형에 후보키가 여러 개 존재하고, 이러한 후보키들이 서로 중첩되어 나타나는 경우에 적용 가능하다.
    5. 제 4정규형
        - 제 4정규형은 테이블 R에 다중 값 종속 A →→ B가 존재할 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형이다.
    6. 제 5정규형
        - 제 5정규형은 테이블 R의 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형이다.


### Section 040. 반정규화 Denormalization

1. 반정규화 (= 비정규화)
    - 반정규화는 시스템의 성능을 향상하고 개발 및 운영의 편의성 등을 높이기 위해 **정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위이다.**
    - 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다.
    - 반정규화 방법
        1. 테이블 통합
            - 테이블 통합은 두 개의 테이블이 조인되어 사용되는 경우가 많을 경우 성능 향상을 위해 아예 하나의 테이블로 만들어 사용하는 것이다.
            - 테이블 통합을 고려하는 경우
                - 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우
                - 항상 두 개의 테이블을 이용하여 조회를 수행하는 경우
            - 테이블 통합의 종류
                - 1:1 관계 테이블 통합
                - 1:N 관계 테이블 통합
                - 슈퍼타입/서브타입 테이블 통합
        2. 테이블 분할
            - 수형 분할
                - 레코드를 기준으로 테이블을 분할하는 것
                - 레코드 별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할함
            - 수직 분할
                - 하나의 테이블에 속성이 너무 많을 경우 속성을 기분으로 테이블을 분할하는 것
                - 종류 : 갱신 위주의 속성 분할, 자주 조회되는 속성 분할, 크기가 큰 속성 분할, 보안을 적용해야하는 속성 분할
        3. 중복 테이블 추가
            - 중복 테이블 추가는 작업의 효율성을 향상시키기 위해 테이블을 추가하는 것이다.
            - 중복테이블을 추가하는 경우
                - 여러 테이블에서 데이터를 추출해서 사용해야 할 경우
                - 다른 서버에 저장된 테이블을 이용해야 하는 경우
            - 중복 테이블 추가 방법
                - 집계 테이블의 추가 - 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것
                - 진행 테이블의 추가 - 이력 관리 등의 목적으로 추가하는 테이블
                - 특정 부분만을 포함하는 테이블의 추가 - 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성
        4. 중복 속성 추가
            - 중복 속성 추가는 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것이다.
            - 중복 속성을 추가하면 데이터의 무결성 확보가 어렵고, 디스크 공간이 추가로 필요하다.
            - 중복 속성을 추가하는 경우
                - 조인이 자주 발생하는 속성인 경우
                - 접근 경로가 복잡한 속성인 경우
                - 액세스의 조건으로 자주 사용되는 속성인 경우
                - 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우


    ### Section 041. 시스템 카탈로그
    
    - 시스템 카탈로그 (System Catalog)
        - 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다.
        - 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다.
        - 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터사전이라고도 한다.
    - 메타 데이터 Meta - Data
        - 메타 데이터는 시스템 카탈로그에 저장된 정보를 의미한다.
        - 메타 데이터 유형
            - 데이터베이스 객체 정보 : 테이블, 인덱스, 뷰 등의 구조 및 통계 정보
            - 사용자 정보 : 아이디, 패스워드, 접근 권한 등
            - 테이블의 무결성 제약 조건 정보 : 기본키, 외래키, NULL 값 허용 여부 등
            - 함수, 프로시저, 트리거 등에 대한 정보
    - 데이터 디렉터리 Data directory
        - 데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템
        - 시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 데이터 디렉터리는 시스템만 접근할 수 있다.

### Section 042. 트랙잭션 분석 / CRUD 분석

1. 트랜잭션 Transation
    - 트랙잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.
    - 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용된다.
    - 트랜잭션은 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용된다.
    - **트랜잭션의 특징**
        - **Atomicity 원자성**
            - 트랙잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구 (Rollback)되어야 함
        - **Consistency 일관성**
            - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
        - **Isolation 독립성, 격리성, 순차성**
            - 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음
        - **Durability 영속성, 지속성**
            - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

1. CRUD 분석
    - 프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것이다.

### Section 043. 인덱스

1. Index
    - 데이터 레코드를 빠르게 접근하기 위해 <키,값,포인터> 쌍으로 구성되는 데이터 구조이다.
    - 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공한다.
    - 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적이다.
    - 인덱스 종류
        - 트리 기반 인덱스 - 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
        - 비트맵 인덱스 - 인덱스 컬럼의 데이터를 Bit 값인 0또는 1로 변환하여 인텍스 키로 사용하는 방법
        - 함수 기반 인덱스 - 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것
        - 비트맵 조인 인덱스 - 다수의 조인된 객체로 구성된 인덱스
        - 도메인 인덱스 - 개발자가 필요한 인덱스를 직접 만들어 사용하는 것

### Section 044. 뷰/클러스터

1. 뷰 View
    - 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
    - 뷰는 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다.
    - 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다.
2. 클러스터 Cluster
    - 클러스터는 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법이다.
    - 클러스터링 된 테이블은 데이터 조회 속도를 향상시키지만 입력, 수정, 삭제에 대한 작업 성능을 저하시킨다.
    - 클러스터는 데이터의 분포도가 넓을수록 유리하다.

### Section 045. 파티션

1. 파티션 Partition
    - 데이터베이스에서 파티션은 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말한다.
    - 대용량 DB의 경우 몇 개의 중요한 테이블에만 집중되어 데이터가 증가되므로, 이런 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방지할 뿐만 아니라 데이터 관리도 쉬워진다.
    - 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션별로 수행된다.
    - 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하됨
    - 파티션의 종류
        - 범위 분할 Range partitioning - 지정한 열의 값을 기준으로 분할함
        - 해시 분할 Hash Partitioning - 해시 함수를 적용한 결과 갑에 따라 데이터를 분할함
        - 조합 분할 Composite Partitioning - 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식

### Section 046. 분산 데이터베이스 설계

1. 데이터베이스 용량 설계
    - 데이터베이스 용량 설계는 데이터가 저장될 공간을 정의하는 것이다.
    - 데이터베이스 용량 설게의 목적
        - 데이터베이스의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높인다.
        - 디스크의 특성을 고려하여 설계함으로써 디스크의 입 출력 부하를 분산시키고 채널의 병목 현상을 최소화한다.
2. 분산 데이터베이스 설계
    - 분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 사이트에 분산된 데이터베이스를 말한다.
    - 분산 데이터베이스는 데이터의 처리나 이용이 많은 지역에 데이터베이스를 위치시킴으로써 데이터의 처리가 가능한 해당 지역에서 해결될 수 있도록 한다.
    - 분산 데이터베이스 설계는 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적으로 한다.
3. 분산 데이터베이스의 목표
    - 위치 투명성 Location Transpatency : 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스 할 수 있다.
    - 중복 투명성 Replication Transparency : 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다.
    - 병행 투명성 Concurrency Transparency : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.
    - 장애 투명성 Failure Transparency : 트랜잭션 DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.
4. 분산 설계 방법
    1. 테이블 위치 분산 - 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법
    2. 분할 - 테이블의 데이터를 분할하여 분산시키는 것
    3. 할당 - 동일한 분할을 여러 개의 서버에 생성하는 분산 방법. 중복이 없는 할당과 중복이 있는 할당으로 나뉨

### Section 047. 데이터베이스 이중화 / 서버 클러스터링

1. 데이터베이스 이중화
    - 데이터베이스 이중화는 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것이다.
    - 데이터베이스 이중화를 수행하면 하나 이상의 데이터베이스가 할상 같은 상태를 유지하므로 데이터베이스에 문제가 발생하면 복제된 데이터베이스를 이용하여 즉시 문제를 해결할 수 있다.
    - 데이터베이스 이중화를 이용하면 손쉽게 백업 서버를 운영할 수 있다.
2. 데이터베이스 이중화의 분류
    - Eager 기법
        - 트랜잭션 수행 중 데이터 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법
    - Lazy 기법
        - 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법.
        - 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨
3. 데이터베이스 이중화 구성 방법
    - 활동 - 대기 방법
        - 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 Db에 장애가 발생하면 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행함
        - 구성 방법과 관리가 쉬워 많은 기업에서 이용됨
    - 활동 - 활동 방법
        - 두 개의 Db가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제송함
        - 두 DB가 모두 처리를 하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡함
4. 클러스터링 Clustering
    - 클러스터링은 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술이다.
    - 클러스터링은 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공한다.
    - 클러스터링 종류
        - 고가용성 클러스터링
            - 하나의 서버에 장애가 발생하면 다른 노드 (서버)가 받아 처리하여 서비스 중단을 방지하는 방식
            - 일반적으로 언급되는 클러스터링이 고가용성 클러스터링임
        - 병렬 처리 클러스터링
            - 전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리하는 방식
5. RTO/RPO
    1. RTO (목표 복구 시간)
        - 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미함.

          ex) 장애 발생 후 6시간 내 복구 가능

    2. RPO (목표 복구 시점)
        - 비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점을 의미함.

          ex) 장애 발생 전인 지난 주 금요일에 백업시켜 둔 복원 시점으로 복구 가능



### Section 048. 데이터베이스 보안

1. 데이터베이스 보안
    - 데이터베이스의 일부 또는 전체에 대해서 권한이 없는 사용자가 액세스 하는 것을 금지하기 위해 사용되는 기술이다.
    - 보안을 위한 데이터 단위는 테이블 전체로부터 특정 테이블의 특정 행과 열에 있는 데이터 값에 이르기까지 다양하다.
2. 암호화 Encryption
    - 암호화는 데이터를 보낼 때 송신자가 지정한 수신자  이외에는 그 내용들을 알 수 없도록 평문을 암호문으로 변환하는 것이다.
    - 암호화 (Encryption) 과정 : 암호화되지 않는 평문을 암호문으로 바꾸는 과정
    - 복호화 (Decryption) 과정 : 암호문을 원래의 평문으로 바꾸는 과정
    - 암호화 기법
        - 개인키 암호 방식 Private Key Encryption
        - 공개키 암호 방식 Public Key Encryption
3. 접근 통제
    - 접근통제는 데이터가 저장된 객체와 이름을 사용하려는 주체 사이의 정보 흐름을 제한하는 것이다.
    - 접근 통제 3요소
        - 접근 통제 정책
        - 접근 통제 메커니즘
        - 접근 통제 보안모델
    - **접근 통제 기술**
        - **임의 접근 통제 (DAC)**
            - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
            - 데이터 소유자가 접근통제 권한을 지정하고 제어함.
            - 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수 도 있음
        - **강제 접근 통제 (MAC)**
            - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
            - 시스템이 접근 통제 권한을 지정함.
            - 데이터베이스 객체별로 보안 등급을 부여할 수 있음
            - 사용자별로 인가 등급을 부여할 수 있음
        - **역할기반 접근통제 (RBAC)**
            - 사용자의 역할에 따라 접근 권한을 부여하는 방식
            - 중앙 관리자가 접근 통제 권한을 지정함
            - 임의접근 통제와 강제 접근 통제의 단점을 보완하였음.
            - 다중 프로그래밍 환경에 최적화된 방식
4. 접근 통제 정책
    - 접근 통제 정책은 어떤 주체가 언제 어디서 어떤 객체에게 어떤 행위에 대한 허용 여부를 정의하는 것이다.
    - 접근 통제 정책의 종류
        - 신분 기반 정책
            - 주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법으로, IBP 와 GBP가 있음
            - IBP : 최소 권한 정책으로, 단일 주체에게 하나의 객체에 대한 허가를 부여함.
            - GBP : 복수 주체에 하나의 객체에 대한 허가를 부여함
        - 규칙 기반 정책
            - 주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법으로 MLP와 CBP가 있음
            - MLP : 사용자나 객체별로 지정된 기밀 분류에 따른 정책
            - CBP : 집단 별로 지정된 기밀 허가에 따른 정책
        - 역할 기반 정책
            - GBP의 변형된 정책으로, 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한하는 방법

### Section 049. 데이터베이스 백업

1. 데이터베이스 백업
    - 데이터베이스 백업은 전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업이다.
2. 로그 파일
    - 로그파일은 데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 모두 기록한 파일이다.
    - 데이터베이스의 복구를 위해 필요한 가장 기본적인 자료이다.
    - 로그 파일을 기반으로 데이터베이스를 과거 상태로 복구 (UNDO) 시키거나 현재 상태로 재생 (REDO) 시켜 데이터베이스 상태를 일관성있게 유지할 수 있다.
3. 데이터베이스 복구 알고리즘
    - NO-UNDO/REDO
        - 데이터베이스 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘
        - NO-UNDO : 트랜잭션 완료 전에는 변경 내용이 데이터베이스에 기록되지 않으므로 취소할 필요가 없음
        - REDO : 트랜잭션 완료 후 데이터베이스 버퍼에는 기록되어 있고, 저장 매체에는 기록되지 않았으므로 트랜잭션 내용을 다시 실행해야 함
    - UNDO/NO-REDO
        - 데이터베이스 버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘
        - UNDO : 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용을 취소함
        - NO-REDO : 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장 매체에 기록했으므로 트랜잭션 내용을 다시 실행할 필요가 없음
    - UNDO/REDO
        - 데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘
        - 데이터베이스 기록 전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 다시 실행해야 함
    - NO-UNDO/NO-REDO
        - 데이터베이스 버퍼의 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우의 복구 알고리즘
        - NO-UNDO : 변경 내용은 데이터베이스와 다른 영역에 기록되어 있으므로 취소할 필요가 없음
        - NO-REDO : 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요가 없음
4. 백업 종류
    1. 백업 종류는 복구 수준에 따라 운영체제를 이용하는 물리 백업과 DBMS 유틸리티를 이용하는 논리 백업으로 나뉜다.
        1. 물리 백업
            - 데이터베이스 파일을 백업하는 방법이다.
            - 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악 및 문제 해결이 어렵다.
        2. 논리 백업
            - DB 내의 논리적 객체들을 백업하는 방법이다.
            - 복원 시 데이터 손상을 막고 문제 발생 시 원인 파악 및 해결이 수월하지만 백업/복원 시 시간이 많이 소요된다.

### Section 050. 스토리지

1. 스토리지 Storage
    - 스토리지는 단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술이다.
    - **스토리지 종류**
        - DAS (Direct Attached Storage)
            - 서버와 저장장치를 전용 케이블로 직접 연결하는 방식
            - 일반 가정에서 컴퓨터에 외장하드를 연결하는 것이 여기에 해당된다.
            - 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉽다.
            - 초기 구축 비용 및 유지 보구 비용이 저렴하다.
            - 직접 연결 방식이므로 다른 서버에서 접근할 수 없고 파일을 공유할 수 없다.
            - 확장성 및 유연성이 떨어진다.
        - NAS (Network Attached Storage)
            - 서버와 저장장치를 너트워크를 통해 연결하는 방식이다.
            - 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리한다.
            - Ethernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유가 가능하다.
            - 장소에 구애받지 않고 저장장치에 쉽게 접근할 수 있다.
            - DAS 에 비해 확장성 및 유연성이 우수하다.
        - SAN (Storage Area Network)
            - DAS의 빠른 처리와  NAS의 파일 공유 장점을 혼합한 방식으로, 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식이다.
            - 광 채널 (FC) 스위치를 이용하여 네트워크를 구성한다.
            - 광 채널 스위치는 서버와 저장장치를 광케이블로 연결하므로 처리 속도가 빠르다.
            - 저장장치를 공유함으로써 여러 개의 저장장치나 백업 장비를 단일화 시킬 수 있다.
            - 확장성, 유연성, 가용성이 뛰어나다.


### Section 051. 논리 데이터 모델의 변환

1. Entity를 테이블로 변환
    - 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환하는 것이다.
    - 변환 규칙


        | 논리적 설계 (데이터 모델링) | 물리적 설계 |
        | --- | --- |
        | 엔티티 Entity | 테이블 Table |
        | 속성 Attribute | 컬럼 Column |
        | 주 식별자 Primary Key | 기본키 Primary Key |
        | 외부 식별자 Foreign Key | 외래키 Foreign Key |
        | 관계 Relationship | 관계 Relationship |

### Section 052. 자료 구조

1. 자료 구조
    - 자료 구조는 자료를 기억장치의 공간 내에 저장하는 방법과 자료 간의 관계, 처리 방법 등을 연구 분석하는 것을 말한다.
    - 저장 공간의 효율성과 실행시간의 단축을 위해 사용한다.
    - **자료 구조의 분류**
        - **선형 구조 (Linear Structure)**
            - 배열 Array
            - 선형 리스트 Linear List
                - 연속 리스트 Contiguous List
                - 연결 리스트 Linked List
            - 스택 Stack
            - 큐 Queue
            - 데크 Deque
        - **비선형 구조 Non-Linear Structure**
            - 트리 Tree
            - 그래프 Graph
    1. 배열 Array
        - 배열은 크기와 형(Type)이 동일한 자료들이 순서대로 나열된 자료의 집합이다.
        - 반복적인 데이터 처리 작업에 적합한 구조
        - 정적인 자료 구조로, 기억장소의 추가가 어렵다.
        - 데이터 삭제 시 기억장소가 빈 공간으로 남아있어 메모리의 낭비가 발생한다.
    2. 연속 리스트
        - 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조이다.
        - 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야한다.
        - 삽입 상제 시 자료의 이동이 필요하다.
    3. 연결 리스트
        - 연결 리스트는 자료들을 임의의 기억공간에 기억시키되, 지료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조이다.
        - 연결을 위한 링크 (포인터) 부분이 필요하기 때문에 기억 공간의 이용 효율이 좋지 않다.
        - 접근 속도가 느리고, 연결이 끊어지면 다음 노드를 찾기 어렵다.
    4. 스택
        - 스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
        - 후입선출 방식으로 자료를 처리한다.
        - 저장할 기억 공간이 없는 상태에서 데이터가 삽입되면 오버 플로가, 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로가 발생한다.
    5. 큐
        - 큐는 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조이다.
        - 선입선출 방식으로 처리한다.
        - 시작을 표시하는 프런트 포인터와 끝을 표시하는 리어(Rear) 포인터가 있다.
    6. 그래프
        - 그래프는 정점(Vertex) 과 간선(Edge)의 두 집합으로 이루어지는 자료 구조이다.
        - 사이클이 없는 그래프를 트리라 한다.
        - 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분된다.
    7. 방향/무방향 그래프의 최대 간선 수
        - 방향 그래프의 최대 간선 수 : n(n-1)
        - 무방향 그래프에서 최대 간선 수 : n(n-1)/2


### Section 053. 트리 Tree

1. 트리 Tree
    - 트리는 정점(Node), 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.
    - 트리는 하나의 기억 공간을 노드라고 하며, 노드와 노드를 연결하는 선을 링크라고 한다.
    - 트리 관련 용어
        - 노드 Node : 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것 ex_ A,B,C,D…
        - 근 노드 (Root Node) : 트리의 맨 위에 있는 노드
        - 디그리 (Dgree: 차수) : 각 노드에서 뻗어나온 가지의 수
        - 단말 노드 (Terminal Node) = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 디그리가 0인 노드
        - 비단말 노드(Non-Terminal Node) : 자식이 하나라도 있는 노드, 즉 Degree가 0이 아닌 노드
        - 조상 노드 (Ancestors Node) : 임의의 노드에서 근 노드에 이르는 경로상에 있는 노드들
        - 자식 노드 : 어떤 노드에 연결된 다음 레벨의 노드들
        - 부모 노드 : 어떤 노드에 연결된 이전 레벨의 노드들
        - 형제 노드 : 동일한 부모를 갖는 노드들
        - Level : 근 노드의 레벨을 1로 가정한 후 어떤 레벨이 L이면 자식 노드는 L+1
        - 깊이 : Tree에서 노드가 가질 수 있는 최대의 레벨
        - 숲 : 여러 개의 트리가 모여 있는 것
        - 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수

### Section 054. 이진 트리

1. 이진 트리
    - 이진 트리는 차수가 2이하인 노드들로 구성된 트리, 즉 자식이 둘 이하인 노드들로만 구성된 트리를 말한다.
    - 이진 트리의 레벨 i에서 최대 노드의 수는 2^i-1 이다.
    - 이진 트리에서 Terminal Node수가 N0, 차수가 2인 노드 수가 n2라 할 때 n0=n2+1이 된다.
2. 트리의 운행법
    - 트리를 구성하는 각 노드들을 찾아가는 방법은 운행법이라고 한다.
    - 이진 트리를 운행하는 방법은 산술식의 표기법과 연관성을 가진다.
    - **Preorder 운행** : Root → Left → Right 순으로 운행한다.
    - **Inorder 운행** : Left → Root → Right 순으로 운행한다.
    - **Postorder 운행** : Left → Right → Root 순으로 운행한다.
3. 수식의 표기법
    - 이진 트리로 만들어진 수식을 인오더, 프리오더, 포스트오더로 운행하면 각각 중위, 전위, 후위 표기법이 된다.
    - **전위 표기법 PreFix** : 연산자 → Left → Right
    - **중위 표기법 InFix** : Left → 연산자 → Right
    - **후위 표기법 PostFix** : Left → Right → 연산자


### Section 055. 정렬 Sort

1. 삽입 정렬 Insertion Sort
    - 삽입 정렬은 가장 간단한 정렬 방식으로, 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식이다.
    - 평균과 최악 모두 수행시간 복잡도가 O(n^2) 이다.
2. 삽입 정렬 Selection Sort
    - 선택 정렬은 n 개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식이다.
    - 평균과 최악 모두 수행 시간 복잡도는 O(N^2)이다.
3. 버블 정렬 Bubble Sort
    - 버블 정렬은 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식이다.
    - 평균과 최악 모두 수행 시간 복잡도는 O(n^2)이다.
4. 쉘 정렬 Shell Sort
    - 쉘 정렬은 입력 파일을 어떤 매개변수의 값으로 서브 파일을 구성하고, 각  서브 파일을 Insertion 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식이다.
    - 삽입 정렬(Insertion Sort)을 확장한 개념이다.
    - 평균 수행 시간 복잡도는 O(n^1.5)이고, 최악의 수행 시간 복잡도는 O(n^2)이다.
5. 퀵 정렬 Quick Sort
    - 퀵 정렬은 키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 과정을 반복하는 정렬 방식이다.
    - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.
    - 평균 수행 시간 복잡도는 O(nlog2n)이고, 최악의 수행 시간 복잡도는 O(n^2)이다.
6. 힙 정렬 Heap Sort
    - 힙 정렬은 전이진 트리를 이용한 정렬 방식이다.
    - 구성된 전이진 트리를 Heap Tree로 변환하여 정렬한다.
    - 평균과 최악 모두 시간 복잡도는 O(nlog2n)이다.
7. 2-way 합볍 정렬 Merge Sort
    - 2-way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다.
    - 평균과 최악 모두 시간 복잡도는 O(nlog2n)이다.
8. 기수 정렬 Radix Sort = Bucket Sort
    - 기수 정렬은 Queue를 이용하여 자릿수(Digit) 별로 정렬하는 방식이다.
    - 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 ㅂ킷의 순서대로 레코드를 꺼내어 정렬한다.
    - 평균과 최악 모두 시간 복잡도는 O(dn)이다.