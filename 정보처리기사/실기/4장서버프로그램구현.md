### Section 062. 개발 환경 구축

1. 하드웨어 환경
    - 하드웨어 환경은 사용자와의 인터페이스 역할을 하는 클라이언드와 클라이언트와 통신하여 서비스를 제공하는 서버로 구성된다.
    - **서버의 종류**
        - **웹 서버 Web Server**
            - 클라이언트로부터 직접 요청을 받아 처리함.
            - 저용량의 정적 파일들을 제공함
        - **웹 애플리케이션 서버 WAS**
            - 동적 서비스를 제공하거나 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행함
        - 데이터베이스 서버 DB Server
            - 데이터베이스와 이를 관리하는 DBMS를 운영함
        - 파일 서버 File Server
            - 데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장함
    1. Web Server 의 기능
        1. HTTP/HTTPS 지원 - 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜
        2. 통신 기록 (Communication Log) - 처리한 요청들을 로그 파일로 기록하는 기능
        3. 정적 파일 관리 (Managing Static Files) - HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능
        4. 대역폭 제한 (Bandwidth Throttling) - 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능
        5. 가상 호스팅 (Virtual Hosting) - 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능
        6. 인증 (Authentication) - 사용자가 합법적인 사용자인지를 확인하는 기능
    2. 소프트웨어 환경
        - 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성된다.
        - 시스템 소프트웨어의 종류 : 운영체게 (OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등
        - 개발 소프트웨어의 종류
            - 요구사항 관리 도구 - 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어
            - 설계/모델링 도구 - UML(통합 모델링 언어)을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어
            - 구현 도구 - 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어
            - 빌드 도구 - 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어
            - 테스트 도구 - 모듈들이  요구사항에 적합하게 구현되었는지 테스트하는 소프트웨어
            - 형상 관리 도구 - 산출물들을 버전별로 관리하여 품질 향상을 지원하는 소프트웨어


### Section 063. 소프트웨어 아키텍처

1. 소프트웨어 아키텍처
    - 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.
    - 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정한다.
    - 소프트웨어 아키텍처 설계의 기본 원리
        - 모듈화 Modularity
            - 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.
            - 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고, 모듈의 크기를 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.
        - 추상화 Abstract
            - 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.
            - 추상화의 유형
                - 과정 추상화 - 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
                - 데이터 추상화 - 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
                - 제어 추상화 - 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법
        - 단계적 분해 Stepwise Refinement
            - 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다.
            - 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다.
        - 정보 은닉 Information Hiding
            - 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다.
            - 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있다.
2. 상위 설계와 하위 설계

    |  | 상위 설계  | 하위 설계  |
    | --- | --- | --- |
    | 별칭  | 아키텍처 설계, 예비 설계  | 모듈 설계, 상세 설계  |
    | 설계 대상  | 시스템의 전체적인 구조  | 시스템의 내부 구조 및 행위  |
    | 세부 목록  | 구조, DB, 인터페이스  | 컴포넌트, 자료 구조, 알고리즘  |
3. 소프트웨어 아키텍처의 설계 과정
    1. 설계 목표 설정 - 요구사항을 분석하여 전체 시스템의 설계 목표 설정
    2. 시스템 타입 설정 - 시스템과 서브 시스템의 타입을 결정하고, 아키텍처 패턴 선택
    3. 아키텍처 패턴 적용 - 시스템의 표준 아키텍처 설계
    4. 서브 시스템 구체화 - 서브 시스템의 기능 및 서브 시스템 간의 상호작용을 위한 동작과 인터페이스 정의
    5. 검토 - 설계 목표, 요구사항, 설계의 기본 원리 등을 만족하는지 아키텍처 검토
4. 협약(Contract)에 의한 설계
    - 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것이다.
    - 명세에 포함될 조건
        - 선행 조건 (Precondition) - 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
        - 결과 조건 (Postcondition) - 오퍼레이션이 수행된 후 만족되어야 할 조건
        - 불변 조건 (Invariant) - 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건


### Section 064. 아키텍처 패턴

1. 아키텍처 패턴
    - 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
    - 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제기한다.
    - 주요 아키텍처 패턴의 종류
        - **레이어 패턴 Layer Pattern**
            - 시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴이다.
            - 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다.
            - 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다.
            - 대표적으로 OSI 참조 모델이 있다.
        - **클라이언트-서버 패턴 Client-Server Pattern**
            - 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다.
            - 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에서 제공하는 방식이다.
        - 파이프- 필터 패턴 Pipe-Filteer Pattern
            - 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴이다.
            - 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복한다.
            - 데이터 변환, 버퍼링, 동기화 등에 주로 사용되며 대표적으로 UNIX 의 Shell 이 있다.
        - 모델-뷰-컨트롤러 패턴 (Model-View-Controller)
            - 서브시스템을 모델, 뷰, 컨트롤럴 구조화하는 패턴이다.
            - 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력하는 구조이다.
        - 기타 패턴
            - 마스터- 슬레이브 패턴 : 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴
            - 브로커 패턴 : 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴
            - 피어-투-피어 패턴 : Peer라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수 도 있는 패턴
            - 이벤트-버스 패턴 : 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스터들이 메시지를 받아 이벤트를 처리하는 패턴
            - 블랙보드 패턴 - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴
            - 인터프리터 패턴 - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴 (EX_ 번역기, 컴파일러, 인터프리터)


### Section 065. 객체지향 (Object-Oriented)

1. 객체지향
    - 소프트웨어의 각 요소들을 객체(Object)로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법이다.
    - 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다.
    - **객체 지향의 구성 요소**
        - **객체 Object** - 데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈이다.
        - **클래스 Class** - 공통된 속성과 연산을 갖는 객체의 집합. 클래스에 속한 각각의 객체를 인스턴스라고 한다.
        - **메시지 Message** - 객체들 간의 상호작용을 하는데 사용되는 수단으로, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항이다.
    - **객체 지향의 특징**
        - 캡슐화 Encapsulation - 외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것이다. 객체들 간에 메시지를 주고 받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다.
        - 상속 Inheritance - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것.
        - 다형성 Polymorphism - 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할수 있는 능력.
        - 연관성 Relationship - 두 개 이상의 객체들이 상호 참조하는 관계를 의미
            - 연관성의 종류
                - is member of - 연관화 - 2개 이상의 객체가 상호 관련되어 있음을 의미
                - is instance of - 분류화 - 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
                - is part of - 집단화 - 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것
                - is a - 일반화 - 공통적인 성질들로 추상화한 상위 객체를 구성하는 것
                  - 특수화/상세화 - 상위 객체를 구체화하여 하위 객체를 구성하는 것


### Section 066. 객체지향 분석 및 설계

1. 객체지향 분석 OOA
    - 객체지향 분석은 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델리하는 작업이다.
    - 개발을 위한 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석한다.
    - 클래스를 식별하는 것이 객체지향 분석의 주요 목적이다.
2. 객체지향 분석의 방법론
    1. Rambaugh 방법 : 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행함
    2. Booch 방법 : 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용함.
    3. Jacobson 방법 : 유스케이스를 강조하여 사용함
    4. Coad 와 Yourdon 방법 : E-R다이어그램을 사용하여 객체의 행위를 모델링함.
    5. Wirfs-Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행함
3. **Rambaugh 방법**
    - 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법이다.
    - 객체 모델링 기법 (OMT)라고도 하며, 분석 활동은 객체모델링 → 동적 모델링 → 기능 모델링 순으로 이루어진다.
        - **객체 모델링 Object Modeling**
            - 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
        - **동적 모델링 Dynamic Modeling**
            - 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
        - **기능 모델링 Functional Modeling**
            - 자료 흐름도를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링
4. **객체지향 설계 원칙**
    - 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜져야 할 원칙이다.
    - SOLID 원칙이라고도 부른다.
    - **객체지향 설계 원칙의 종류**
        - **단일 책임의 원칙 SRP :** 객체는 단 하나의 책임만 가져야 한다는 원칙
        - **개방 - 폐쇄 원칙 OCP** : 기존의 코드를 변경하지 않고 가능을 추가할 수 있도록 설계해야 한다는 원칙
        - **리스코프 치환 원칙 LSP** : 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙
        - **인터페이스 분리 원칙 ISP :** 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
        - **의존 역전 원칙 DIP** : 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙

### Section 067. 모듈

1. **모듈 Module**
    - 모듈화를 통해 분리된 시스템의 각 기능으로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등을 의미한다.
    - 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미한다.
    - 모듈의 독립성은 결합도 (Coupling) 와 응집도 (Cohesion)에 의해 측정된다.
2. **결합도 Coupling**
    - 결합도는 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계이다.
    - 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다.
    - **결합도의 종류**
        - 내용 결합도 Content Coupling

          한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도

        - 공통 (공유) 결합도 Common Coupling

          공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도.
          파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도

### Section 068. 단위 모듈

1. 단위 모듈 Unit Module
    - 단위 모듈은 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것이다.
    - 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다.
    - 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다.
2. **IPC (Inter-Process Communication)**
    - IPC는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합이다.
    - 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.
    - IPC의 대표 메소드 5가지
        - Shared Memory - 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식
        - Socket - 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스 간에 통신하는 방식
        - Semaphores - 공유 자원에 대한 접근 제어를 통해 통신하는 방식
        - Pipes&named Pipes - Pipe 라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식. 하나의 프로세스가 이용 중이라면 다른 프로세스는 접근할 수 없음.
        - Message Queueing - 메시지가 발생하면 이를 전달하는 방식으로 통신하는 방식
3. **테스트 케이스 Test Case**
    - 테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수 했는지를 확인하기 위한 테스트 항목에 대한 명세서이다.
    - 테스트 케이스를 이용하지 않은 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다.

### Section 069. 공통 모듈

1. 공통 모듈
    - 공통 모듈은 여러 프로그램에서 공통으로 사용할 수 있는 모듈이다.
    - 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 공통 모듈로 구성될 수 있다.
    - 공통 모듈 명세 기법의 종류
        - 정확성 Correctness - 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성함
        - 명확성 Clarity - 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성함
        - 완전성 Completness - 시스템 구현을 위해 필요한 모든 것을 기술함
        - 일관성 Consistency - 공통 기능들 간 상호 충돌이 발생하지 않도록 작성함
        - 추적성 Traceability - 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성함
2. 재사용 Reuse
    - 재사용은 이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업이다.
    - 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야한다.
    - 재사용 규모에 따른 분류
        - 함수와 객체 - 클래스나 메소드 단위의 소스 코드를 재사용함
        - 컴포넌트 - 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈. 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용함.
        - 애플리케이션 - 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용함.
3. 효과적인 모듈 설계 방안 (가볍게 읽고 넘어가기)
    - 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다.
    - 복잡도와 중복성을 줄이고 일관성을 유지시킨다.
    - 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안된다.
    - 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다.
    - 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야한다.

### Section 070. 코드

1. 코드 Code
    - 자료의 분류, 조합, 집계, 추출을 용이하게 하기 위해 사용하는 기호이다.
2. 코드의 주요 기능
    - 식별 기능 - 데이터간의 성격에 따라 구분이 가능함
    - 분류 기능 - 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있음.
    - 배열 기능 - 의미를 부여하여 나열할 수 있음
    - 표준화 기능 - 다양한 데이터를 기준에 맞추어 표현할 수 있음
    - 간소화 기능 - 복잡한 데이터를 간소화할 수 있음
3. 코드의 종류
    - 순차 코드 Sequence Code
        - 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법으로, 순서 코드 또는 일련번호라고도 함
        - ex_ 1,2,3,4
    - 블록 코드 Block Code
        - 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로, 구분코드라고도 함
        - ex_ 1001~1100: 총무부, 1101~1200: 영업부
    - 10진 코드 Decimal Code
        - 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 함
        - ex_ 1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계
    - 그룹 분류 코드 Group Classification Code
        - 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법임
        - ex_ 1-01-001: 본사 - 총무부 - 인사계, 2-01-001 : 지사 - 총무부 - 인사계
    - 연상 코드 Mnemonic Code
        - 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법임
        - ex_ TV-40: tv 40인치, L-15-220 : 15W 220V의 램프
    - 표의 숫자 코드 Significant Digit Code
        - 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수피를 그대로 코드에 적용시키는 방법으로, 유효 숫자 코드라고도 함
        - ex_ 120-720-1500: 두께X폭X길이가 120X720X1500인 강판
    - 합성 코드 Combined Code
        - 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법임
        - ex_ 연상 코드 + 순차 코드       KE-711: 대한항공 711기

### Section 071. 디자인 패턴

1. 디자인 패턴 Design Pattern
    - 디자인 패턴은 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제를 의미한다.
    - 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다.
    - GOF의 디자인패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분된다.
2. **생성 패턴 Creational Pattern**
    - 생성 패턴은 클래스나 객체의 생성과 참조 과정을 정의하는 패턴이다.
    - **추상 팩토리 Abstract Factory**
        - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함. 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능함
    - **빌더 Builder**
        - 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함
        - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음
    - **팩토리 메소드 Factory Method**
        - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
        - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함
        - 가상 생성자 (Virtual Constructor) 패턴이라고도 함
    - **프로토타입 Prototype**
        - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
        - 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용함
    - **싱글톤 Singleton**
        - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음
        - 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화할 수 있음

1. **구조 패턴 Structural Pattern**
    - 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴이다.
    - **어댑터 Adapter**
        - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
        - 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용함
    - **브리지 Bridge**
        - 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
        - 기능과 구현을 두 개의 별도 클래스로 구현함
    - **컴포지트 Composite**
        - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
        - 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음
    - **데코레이터 Decorator**
        - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
        - 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현함
    - **퍼싸드 Facade**
        - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
        - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함
    - **플라이웨이트 Flyweight**
        - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한한 공유해서 사용함으로써 메모리를 절약하는 패턴
        - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음
    - **프록시 Proxy**
        - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴으로, 대리자라고도 불림
        - 내부에서는 객체 간의 복잡한 관계를 단순하게 정리하고 외부에서는 객체의 세부적인 내용을 숨김
2. **행위 패턴 Behavioral Pattern**
    - 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.
    - **책임 연쇄 Chain of Responsibility**
        - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
        - 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감
    - **커맨드 Command**
        - 요청을 객체의 형태로 캡슐화하려 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
        - 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함
    - **인터프리터 Interpretor**
        - 언어에 문법 표현을 정의하는 패턴
        - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용함
    - **반복자 Iterator**
        - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
        - 내부 표현 방법의 노출 없이 순차적인 접근이 가능함
    - **중재자 Mediator**
        - 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴
        - 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음
    - **메멘도 Memento**
        - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
        - Ctrl+Z와 같은 되돌리기 기능을 개발할 때 주로 이용함
    - **옵서버 Observer**
        - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
        - 일대다의 의존성을 정의함
        - 주로 분산된 시스템 간에 이벤트를 생성 발행하고, 이를 수진해야할 때 이용함
    - **상태 State**
        - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
        - 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리함
    - **전략 Strategy**
        - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
        - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함
    - **템플릿 메소드 Template Method**
        - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
        - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌