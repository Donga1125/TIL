### Section 062. 개발 환경 구축

1. 하드웨어 환경
    - 하드웨어 환경은 사용자와의 인터페이스 역할을 하는 클라이언드와 클라이언트와 통신하여 서비스를 제공하는 서버로 구성된다.
    - **서버의 종류**
        - **웹 서버 Web Server**
            - 클라이언트로부터 직접 요청을 받아 처리함.
            - 저용량의 정적 파일들을 제공함
        - **웹 애플리케이션 서버 WAS**
            - 동적 서비스를 제공하거나 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행함
        - 데이터베이스 서버 DB Server
            - 데이터베이스와 이를 관리하는 DBMS를 운영함
        - 파일 서버 File Server
            - 데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장함
    1. Web Server 의 기능
        1. HTTP/HTTPS 지원 - 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜
        2. 통신 기록 (Communication Log) - 처리한 요청들을 로그 파일로 기록하는 기능
        3. 정적 파일 관리 (Managing Static Files) - HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능
        4. 대역폭 제한 (Bandwidth Throttling) - 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능
        5. 가상 호스팅 (Virtual Hosting) - 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능
        6. 인증 (Authentication) - 사용자가 합법적인 사용자인지를 확인하는 기능
    2. 소프트웨어 환경
        - 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성된다.
        - 시스템 소프트웨어의 종류 : 운영체게 (OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등
        - 개발 소프트웨어의 종류
            - 요구사항 관리 도구 - 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어
            - 설계/모델링 도구 - UML(통합 모델링 언어)을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어
            - 구현 도구 - 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어
            - 빌드 도구 - 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어
            - 테스트 도구 - 모듈들이  요구사항에 적합하게 구현되었는지 테스트하는 소프트웨어
            - 형상 관리 도구 - 산출물들을 버전별로 관리하여 품질 향상을 지원하는 소프트웨어


### Section 063. 소프트웨어 아키텍처

1. 소프트웨어 아키텍처
    - 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.
    - 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정한다.
    - 소프트웨어 아키텍처 설계의 기본 원리
        - 모듈화 Modularity
            - 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.
            - 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고, 모듈의 크기를 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.
        - 추상화 Abstract
            - 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.
            - 추상화의 유형
                - 과정 추상화 - 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
                - 데이터 추상화 - 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
                - 제어 추상화 - 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법
        - 단계적 분해 Stepwise Refinement
            - 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다.
            - 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다.
        - 정보 은닉 Information Hiding
            - 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다.
            - 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있다.
2. 상위 설계와 하위 설계

    |  | 상위 설계  | 하위 설계  |
    | --- | --- | --- |
    | 별칭  | 아키텍처 설계, 예비 설계  | 모듈 설계, 상세 설계  |
    | 설계 대상  | 시스템의 전체적인 구조  | 시스템의 내부 구조 및 행위  |
    | 세부 목록  | 구조, DB, 인터페이스  | 컴포넌트, 자료 구조, 알고리즘  |
3. 소프트웨어 아키텍처의 설계 과정
    1. 설계 목표 설정 - 요구사항을 분석하여 전체 시스템의 설계 목표 설정
    2. 시스템 타입 설정 - 시스템과 서브 시스템의 타입을 결정하고, 아키텍처 패턴 선택
    3. 아키텍처 패턴 적용 - 시스템의 표준 아키텍처 설계
    4. 서브 시스템 구체화 - 서브 시스템의 기능 및 서브 시스템 간의 상호작용을 위한 동작과 인터페이스 정의
    5. 검토 - 설계 목표, 요구사항, 설계의 기본 원리 등을 만족하는지 아키텍처 검토
4. 협약(Contract)에 의한 설계
    - 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것이다.
    - 명세에 포함될 조건
        - 선행 조건 (Precondition) - 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
        - 결과 조건 (Postcondition) - 오퍼레이션이 수행된 후 만족되어야 할 조건
        - 불변 조건 (Invariant) - 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건


### Section 064. 아키텍처 패턴

1. 아키텍처 패턴
    - 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
    - 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제기한다.
    - 주요 아키텍처 패턴의 종류
        - **레이어 패턴 Layer Pattern**
            - 시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴이다.
            - 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다.
            - 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다.
            - 대표적으로 OSI 참조 모델이 있다.
        - **클라이언트-서버 패턴 Client-Server Pattern**
            - 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다.
            - 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에서 제공하는 방식이다.
        - 파이프- 필터 패턴 Pipe-Filteer Pattern
            - 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴이다.
            - 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복한다.
            - 데이터 변환, 버퍼링, 동기화 등에 주로 사용되며 대표적으로 UNIX 의 Shell 이 있다.
        - 모델-뷰-컨트롤러 패턴 (Model-View-Controller)
            - 서브시스템을 모델, 뷰, 컨트롤럴 구조화하는 패턴이다.
            - 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력하는 구조이다.
        - 기타 패턴
            - 마스터- 슬레이브 패턴 : 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴
            - 브로커 패턴 : 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴
            - 피어-투-피어 패턴 : Peer라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수 도 있는 패턴
            - 이벤트-버스 패턴 : 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스터들이 메시지를 받아 이벤트를 처리하는 패턴
            - 블랙보드 패턴 - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴
            - 인터프리터 패턴 - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴 (EX_ 번역기, 컴파일러, 인터프리터)